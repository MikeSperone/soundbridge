#!/usr/bin/env node

var app    = require("../app");
var server = require('http').Server(app);
var io	   = require('socket.io')(server);

const PORT = '9001';
const DEBUG = process.env.NODE_ENV === "development";

const User = require('./userEvents');
const users = {
    all: {},
    availablePerformerSlots: 4,
    performer: [],
    audience: []
};
/**
*  Setting Numbers
*/
const newSetting = function() {
    const i = Math.floor(Math.random() * 29);
    console.info("Setting changed to " + i);
    return i;
};

var currentSetting = newSetting();

io.on('connection', function(socket){

    const user = new User(socket);

    const numberOfUsers = io.engine.clientsCount;
    console.info('users connected: ', numberOfUsers);

    socket.emit('connection', { users, currentSetting })
    function emit(name, data) {
        DEBUG && console.info(name + ": ", data);
        socket.emit(name, data);
    }

    //TODO: I guess eventually, this should go outside of this function.
    // BUT, also it should go per "room", not overall - right?
    setInterval(function(){
        currentSetting = newSetting();
        // this socket is the part I'll need to consider.  It doesn't exist
        // above, so :/
        emit('setting', { currentSetting });
    }, 60 * 1000 * 30);

    function setupPerformer() {

        users.availablePerformerSlots = users.availablePerformerSlots - 1;
        users.performer.push(user.uuid);

        socket.on('data', function(d) {
            socket.broadcast.emit('data', d);
        });
        socket.on('enter', function(d) {
            socket.broadcast.emit('enter', d);
        });
        socket.on('exit', function(d) {
            socket.broadcast.emit('exit', d);
        });
    }

    socket.on('login', function(d) {
        console.info('user logging in, ', d);
        const error = [];
        const { username, requestsPerformer } = d;

        // Validate user data
        if (!username || typeof username !== 'string') {
            console.info('invalid username', username);
            socket.emit('loggedin', { success: false, error: 'Invalid or missing username.' });
            return;
        }

        var userType = (requestsPerformer && users.availablePerformerSlots > 0) ?
            'performer' :
            'audience';

        user.join(username, userType);

        const public_user_info = user.public_info();
        user.connected();
        // users.audience[user.uuid] = user;
        users.all[user.uuid] = public_user_info;

        if (userType === 'performer') setupPerformer();
        else users.audience.push(user.uuid);

        console.info('successful login');
        socket.broadcast.emit('user.login', { users });

        socket.emit('loggedin', {
            success: true,
            user: public_user_info,
            users,
            currentSetting
        });

        socket.on('chat', d => io.emit('chat.inbox', d));

        console.info('users: ', users);
    });

    socket.on('logout', function(d) {
        console.log('logout', d);
        socket.broadcast.emit('user.exited', { users });
    });

    socket.on('disconnect', () => {
        console.info('user left');
        if (user.type && user.uuid && users.all[user.uuid]) {
            console.info('disconnecting user ', user.public_info());
            delete users['all'][user.uuid];
            // get index of user in array;
            const index = users[user.type] && users[user.type].indexOf(user.uuid);
            if (index !== -1) {
                users[user.type].splice(index, 1);
                user.disconnected();
                delete user;
            }
            users.availablePerformerSlots += 1;
            console.info('users, after deleting', users);
            socket.broadcast.emit('user.exited', { users });
        } else {
            console.info('unable to disconnet user', user.public_info());
        }
    })

});

console.log('connecting...');
server.listen(Number(PORT), function() {
    console.log('connected to port ' + PORT);
});

